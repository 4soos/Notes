# 常见编译器

## gcc / g++

GNU开发的一种程序语言编译器。
它是根据GNU通用公共许可证（GPL）和GNU较小通用公共许可证（LGPL）发布的一组免费软件。
GNU和Linux系统的官方编译器，也是用于编译和创建其他UNIX操作系统的主要编译器。

## gcc编译流程

hello.c --> hello.i --> hello.s --> hello.o --> hello.out

1. 预处理， C 编译器对各种预处理命令进行处理，包括头文件包含、宏定义的扩展、条件编译的选择等；

2. 编译，将预处理得到的源代码文件，进行“翻译转换”，产生出机器语言的目标程序，得到机器语言的汇编文件；

3. 汇编，将汇编代码翻译成了机器码，但是还不可以运行；

4. 链接，处理可重定位文件，把各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。

### gcc 命令

#### 1. 预处理

```bash
gcc -E hello.c –o hello.i
```

对文件在中的头文件, 宏进行展开 


#### 2. 编译
```bash
gcc -S hello.i
```
得到对应机器的汇编文件


#### 3. 汇编
```bash
gcc -c hello.s
```
汇编代码到机器码


#### 4. 链接
```bash
gcc hello.o
```
将各个机器码进行链接

#### 动态链接和静态链接：

- 动态链接使用动态链接库进行链接，生成的程序在执行的时候需要加载所需的动态库才能运行。动态链接生成的程序小巧，但是必须依赖动态库，否则无法执行。

- Linux 下的动态链接库实际是共享目标文件（shared object），一般是.so 文件，作用类似于 Windows 下的.dll 文件。

- 静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过体积较大。

- Linux 下静态库是汇编产生的.o 文件的集合，一般以.a 文件形式出现。

gcc 默认是动态链接，加上-static 参数则采用静态链接。

```bash
gcc hello.o -static -o hello_static
```

> -save-temps 保存所有编译过程中产生的文件
> gcc/clang -save-temps *.c


## clang / clang++
LVM包含一系列模块化的编译器组件和工具链。
它可以在编译，运行时和空闲时间优化程序语言和链接，并生成代码。LLVM可以作为多种语言的编译器的背景。
Clang是一种C，C ++，Objective-C或Objective-C ++编译器，它基于LLVM用C ++编译，并根据Apache 2.0许可发行。Clang主要用于提供优于GCC的性能。

## cl.exe

cl.exe是Microsoft C/C++编译器, 只能在支持Microsoft Visual Studio 的操作系统中运行

# 字节对齐

## 对齐定义

现代计算机中，内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。
但实际中在访问特定类型变量时经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。

> 对齐模数
> 内存对齐中指定的对齐数值K成为对齐模数(Alignment Modulus).
> 当一种类型S的对齐模数与另一种类型T的对齐模数的比值是大于1的整数,我们就称类型S的对齐要求比T强(严格),而称T比S弱(宽松).


## Why ?

不同硬件平台对存储空间的处理上存在很大的不同。
某些平台对特定类型的数据只能从特定地址开始存取，而不允许其在内存中任意存放。
例如Motorola 68000 处理器不允许16位的字存放在奇地址，否则会触发异常，因此在这种架构下编程必须保证字节对齐。

但最常见的情况是，如果不按照平台要求对数据存放进行对齐，会带来存取效率上的损失。
比如32位的Intel处理器通过总线访问(包括读和写)内存数据。
每个总线周期从偶地址开始访问32位内存数据，内存数据以字节为单位存放。
如果一个32位的数据没有存放在4字节整除的内存地址处，那么处理器就需要2个总线周期对其进行访问，显然访问效率下降很多。

因此，通过合理的内存对齐可以提高访问效率。为使CPU能够对数据进行快速访问，数据的起始地址应具有“对齐”特性。
比如4字节数据的起始地址应位于4字节边界上，即起始地址能够被4整除。

此外，合理利用字节对齐还可以有效地节省存储空间。
但要注意，在32位机中使用1字节或2字节对齐，反而会降低变量访问速度。
因此需要考虑处理器类型。还应考虑编译器的类型。在VC/C++和GNU GCC中都是默认是4字节对齐。

### 数据类型对应字节数

#### 32位编译器
char ：1个字节
char*（即指针变量，只与地址寻址范围有关）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
long: 4个字节
long long: 8个字节
unsigned long: 4个字节

#### 64位编译器

char ：1个字节
char*(即指针变量): 8个字节
short int : 2个字节
int： 4个字节
unsigned int : 4个字节
float: 4个字节
double: 8个字节
long: 8个字节
long long: 8个字节
unsigned long: 8个字节


### 补充
64位处理器不代表一次访存“只能”读取64位数据。因为它可以一次取出一大块数据拆开放进多个64位（或者更宽的扩展）寄存器里。以ARMv8 AARCH64指令集为例，有可以可以一次读取64bit pair或者128bit的访存指令（其实还有读128bit pair指令）。具体实现的时候，如果地址是16字节对齐的话，是可以一次从内存取出128bit数据的。类似地，x86的SSE扩展可以一次读出16字节一点都不奇怪，出于性能角度考虑要求此类指令对于16字节对齐一点也很正常。

作者：PP Chen
链接：https://www.zhihu.com/question/323890604/answer/721241010
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



看处理器微结构上古处理器l1d 结构比较简单，8B不对齐可能会有多次访问的问题后来复杂一些，基本上只要保证64B对齐就可以一次访问，既访问地址＋访问长度不要超过一个cache line，这个原则一直维持到现在后来进一步增强，虽然64B不对齐，但是性能损失也可以接受，如果你的算法使用64B非对齐可以大幅改进性能，往往你就可以用了

作者：kknd1394
链接：https://www.zhihu.com/question/323890604/answer/681930342
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。












